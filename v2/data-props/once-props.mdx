---
title: Once Props
---

Some data rarely changes or is expensive to compute. Rather than resolving this data on every request, you may use _once props_. These props are remembered by the client and reused on subsequent pages that include the same prop. This makes them ideal for [shared data](/v2/data-props/shared-data).

## Creating Once Props

To create a once prop, use the `Inertia::once()` method when returning your response. This method receives a callback that returns the prop data.

```php
return Inertia::render('Settings', [
    'countries' => Inertia::once(fn () => Country::all()),
]);
```

Once the client has received this prop, subsequent requests will skip resolving the callback entirely and the prop will be excluded from the response. The client will automatically reuse the remembered value.

Keep in mind that navigating to a page that doesn't include the once prop will break the chain. The backend will resolve the prop again when you navigate to a page that includes it.

## Sharing Once Props

You may share once props globally using the `Inertia::share()` method.

```php
Inertia::share('countries', Inertia::once(fn () => Country::all()));
```

Or use the `shareOnce()` helper method.

```php
Inertia::shareOnce('countries', fn () => Country::all());
```

You may also define a dedicated `shareOnce()` method in your middleware.

```php
class HandleInertiaRequests extends Middleware
{
    public function shareOnce(Request $request): array
    {
        return [
            'countries' => fn () => Country::all(),
        ];
    }
}
```

## Forcing a Refresh

You may force a once prop to be refreshed using the `fresh()` method.

```php
return Inertia::render('Settings', [
    'countries' => Inertia::once(fn () => Country::all())->fresh(),
]);
```

This method accepts a boolean, allowing you to conditionally refresh the prop.

```php
return Inertia::render('Settings', [
    'preferences' => Inertia::once(fn () => $user->preferences)->fresh($user->wasChanged()),
]);
```

## Setting an Expiration

You may set an expiration time using the `until()` method. This method accepts a `DateTimeInterface`, `DateInterval` instance, or an integer number of seconds. The prop will be refreshed on a subsequent visit after the expiration time has passed.

```php
return Inertia::render('Dashboard', [
    'rates' => Inertia::once(fn () => ExchangeRate::all())->until(now()->addHour()),
]);
```

## Custom Keys

You may assign a custom key using the `as()` method. This is useful when you want to share data across multiple pages while using different prop names.

```php
// Checkout page
return Inertia::render('Checkout', [
    'shippingCountries' => Inertia::once(fn () => Country::all())->as('countries'),
]);

// Settings page
return Inertia::render('Settings', [
    'availableCountries' => Inertia::once(fn () => Country::all())->as('countries'),
]);
```

Both pages share the same underlying data because they use the same custom key. The prop will only be resolved once, even though the prop names differ.

## Prefetching

Once props work with [prefetching](/v2/data-props/prefetching). The client automatically includes any remembered once props in prefetched responses, so navigating to a prefetched page will already have the once props available.

The prefetch cache also respects once prop expiration. Prefetched pages containing an expired once prop will be invalidated.

## Combining with Other Prop Types

The `once()` modifier may be chained onto [deferred](/v2/data-props/deferred-props), [merge](/v2/data-props/merging-props), and [optional](/v2/data-props/partial-reloads#lazy-data-evaluation) props.

```php
return Inertia::render('Dashboard', [
    'countries' => Inertia::defer(fn () => Country::all())->once(),
    'activity' => Inertia::merge(fn () => $user->recentActivity())->once(),
    'categories' => Inertia::optional(fn () => Category::all())->once(),
]);
```
